---
title: "BioinoRmatika"
output: html_notebook
---


Instaliranje paketa Biostrings:

```{r}
#source("http://bioconductor.org/biocLite.R")
#biocLite("Biostrings")
```

Ucitavanje paketa:

```{r}
require(Biostrings)
```


String  

```{r}
s = "CTGT"

s

```

DNA String 

```{r}
dnastring = DNAString("CTGT")
dnastring

```

```{r}
#dnastring = DNAString("QXZ")
```


```{r}
DNA_ALPHABET
```
```{r}
AA_ALPHABET
```

```{r}
dnastring = DNAString("TTGAAA-CTC")
dnastring
```

```{r}
alphabetFrequency(dnastring)
```

```{r}
alphabetFrequency(dnastring, baseOnly = TRUE, as.prob = TRUE)
```


```{r}
length(dnastring)
```

```{r}
dnastring[1]
dnastring[1:3]
```

```{r}
dnastring2 = DNAStringSet(c("ACGTAAATCTC", "GTCAATCTA", "GCTATCTCATC"))
dnastring2 = DNAStringSet(c("ACGTAAATCTC", "GTCAATCTA", "GCTATCTCATC"),  start = c(5,2,3))
dnastring2
```

```{r}
dnastring2[[2]]

```
[2]
```{r}
codons(dnastring2[[2]])
```


Reverse compement
```{r}
reverseComplement(dnastring)
```

1. zadatak

Ucitaj sekvencu DNA (ATGTACGTCGTCGGTAATTTCATTTAA) kao DNAString te odredi frekvenciju pojavljivanja nukleotida A u sekvenci. 

```{r}
DNAseq = DNAString("ATGTACGTCGTCGGTAATTTCATTTAA")

letterFrequency(DNAseq, "A", as.prob = TRUE)
```

```{r}
subseq(DNAseq, start=3, end=3)
```

```{r}
toString(DNAseq)
```


2. zadatak

Odredi sekvencu proteina iz RNA koja je transkribirana iz DNA sekvence iz prethodnog zadatka. 

```{r}
#RNAseq = transcribe (DNAString)
transcribe = function (dna) {
    rna = (RNAString(dna))
    return (rna)
}

RNAseq = transcribe(DNAseq)
RNAseq 

translate(RNAseq)
translate(DNAseq)
```

```{r}
GENETIC_CODE 
GENETIC_CODE [["TTT"]]
```

Drugi nacin:

```{r}

DNAseq = DNAString("ATGTACGTCGTCGGTAATTTCATTTAA")

protein = "" 

for(i in seq(1,length(DNAseq),3)){
    
    x = as.character(substr(DNAseq,i,i+2))
    y = GENETIC_CODE [[x]]
    protein = paste(protein, y, sep = "")
}

p = AAString(protein)
p
```

```{r}

DNAseq = DNAString("ATGTACGTCGTCGGTAATTTCATTTAA")

protein = AAString()

for(i in seq(1,length(DNAseq),3)){
    
    x = toString(substr(DNAseq,i,i+2))
    y = GENETIC_CODE [[x]]
    protein = append(protein, y)
}

protein
```

Trazenje motiva 

```{r}

freqCG = countPattern("CG", DNAseq) 
freqCG
```

```{r}
matchPattern("CGC", DNAseq ,max.mismatch = 1)
```

3. zadatak

Nadi mjesta pojavljivanja motiva "GGT" u sekvenci DNAseq te u njenom - lancu. Maksimalni broj gresaka moze biti 1. 


```{r}
query = DNAString("GGT")
max.mismatch = 1

fwd = matchPattern(query, DNAseq, max.mismatch = max.mismatch)

DNAseq_rev = reverse (DNAseq)
rev = matchPattern(reverseComplement(query), DNAseq_rev, max.mismatch = max.mismatch)


complete = c(fwd, rev)
complete
```


4. zadatak 

Nadi otvorene okvire citanja u sekvenci DNA (ATGCAATGGGGAAATGTTACCAGGTCCGAACTTATTGAGGTAGACAGATTTAA)

```{r}
 findPotentialStartsAndStops = function(sequence) 
  {
     #Definiramo start i stop kodone
     codons = c("ATG", "TAA", "TAG", "TGA")
     
     
     for (i in 1:4)
     {
        codon = codons[i] #svaki od kodona uzimamo
        
        occurrences = matchPattern(codon, sequence) #mjesta pojave kodona
        
        codonpositions = start (occurrences) #pozicija kodona
       
        numoccurrences = length(codonpositions) #koliko puta se kodon pojavljuje
        if (i == 1){
           positions = codonpositions #spremnanje prve pozicije
          
           types = rep(codon, numoccurrences) #spremanje tipa
        }
        else
        {
           
           positions = append(positions, codonpositions, after = length(positions)) #dodavanje
           
           types = append(types, rep(codon, numoccurrences), after = length(types)) #dodavanje
        }
     }
     
     indices = order(positions) #sortiranje (uzlazno)
     positions = positions[indices]
     types = types[indices]
     mylist = list(positions,types) #ispis u listi
     return(mylist)
 }


```

```{r}
DNAseq2 = DNAString("ATGCAATGGGGAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGATTTAA")
findPotentialStartsAndStops (DNAseq2)
```


```{r}
findORFSeq = function(sequence){

mylist = findPotentialStartsAndStops(sequence) #lista pozicija start i stop kodona
positions = mylist[[1]] 
types = mylist[[2]]

orfstarts = numeric() #vektor start pozicija
orfstops = numeric() #vektor stop pozicija 
orflengths = numeric() #vektor duzina 

numpositions = length(positions)#koliko imamo start i stop kodona

    if (numpositions >= 2) {#mora postojati bar jedan start i jedan stop kodon za ORF (1+1)

        for (i in 1:(numpositions-1)){#ne zanima nas zadnja pozicija jer ona nije start kodon
            posi = positions[i] 
            typei = types[i]
            found = 0 #brojac
            while (found == 0){ #trazimo drugi kodon
                for (j in (i+1): numpositions){ #ne zanima nas prva pozicija jer je ona start kodon
                    posj = positions[j]
                    typej = types[j]
                    posdiff = posj - posi #razlika izmedu pozicija
                    posdiffmod3 = posdiff %% 3 #je li u u okviru citanja!!!
                    orflength = posj - posi + 3 #za stop kodon dodajemo + 3
                    if (typei == "ATG" && (typej == "TAA" || typej == "TAG" || typej == "TGA") && posdiffmod3 == 0) #prvi kodon je start, a drugi stop
                    { #provjera jesmo li vec koristili taj kodon (stop)
    
                        numorfs = length(orfstops) 
                        usedstop = -1 #nije koristen - stanje prije provjere
                        if (numorfs > 0){
                            for (k in 1: numorfs){
                                orfstopk = orfstops[k]
                                if (orfstopk == (posj + 2)) { usedstop = 1 }
                            }
                        }
                        if (usedstop == -1){ #ako nije koristen, dodaje se u listu
                            orfstarts = append(orfstarts, posi,after = length(orfstarts))
                            orfstops = append(orfstops, posj+2,after = length(orfstops)) 
                            orflengths = append(orflengths, orflength,after=length(orflengths))
                        }
                        found = 1 #samo jedan start ili stop kodon za taj orf
                        break
                    }
                    if (j == numpositions) { found = 1 } #samo jedan start ili stop kodon
                }
            }
        }
    }
    

    indices = order(orfstarts) #sortiranje pozicija
    orfstarts = orfstarts[indices]
    orfstops = orfstops[indices]

    orflengths = numeric() #kolike su duljine orf-ova
    numorfs = length(orfstarts)
        for (i in 1:numorfs){
            orfstart = orfstarts[i]
            orfstop = orfstops[i]
            orflength = orfstop - orfstart + 1
            orflengths = append(orflengths,orflength,after = length(orflengths))
        }

    mylist = list(orfstarts, orfstops, orflengths)
    return(mylist)
}


```


```{r}
findORFSeq(DNAseq2)
```


```{r}
#install.packages("systemPipeR")
#library(systemPipeR)

#predORF(DNAseq2, n = 1, type = "grl", mode = "orf", strand = "sense", longest_disjoint = FALSE, startcodon = "ATG", stopcodon = c("TAA", "TAG", "TGA"))
```

Hammingova udaljenost


Dva objekta tipa DNAString:

```{r}
s1 = DNAString("ACTGTACCAGAATCGCTATTAGCCCACCTTAGGCGAGTGAAATAACCAAATAAACAAGTGGTGAGGGGAATTGTCCCCACCGTTGCGTTTATGGAGGGGGTGGAAGTGGCCACGAACTGCCAGGTGTCGCCAAACGGAAGACTTCGGGCTTTAGATCCGACTTAACTAACATTTTTCCACCATGAAAGGAGCAATTCAAAGCAACGTAAGGTACTTGCCTGGCCAGGTTGATAAAAGATGCGGACGTCTGATGATGTACGATGATCTTGGCGAGTCAAACCCGGGGACCCCGAGCCGTGACCTAGAGATTGCAATACAGTAAGTAGCCAGGAAAGGAGGATACGATATAAATTAGGGTCACTGTACCCGTTCCGCCTTTCTGCGGCCAAAGACCCGCACGACACATGGACGCCACAGAGGCTATTTGGACCGATGACTCAGGATCATCAAGGGCGACGACGTTAGTCAGTTATATCTGACATTGGATATGTTATAAATAAAACTGGTAACCCACAACGATCCCGGTAGTGGGGACACTGGCCAGGCTTCTAAGCAGATGCGAGGCACAGACACAAACCGGCCGTATGTCAGAGGCAGTACTGAAGTCTAACTTTATCCACGGCAGACGCGTTACATGGCAATCTTGAGCGGGGCGAAGTTAGAGACGTTAAGCTATATGAAACACACTCGGCGTAGCCAATAGCCCATCTGCCTCATAAGGATGGCTGGTTCATTTGTAAAATACTGTATCAGGCGGGGGTAACCTCCCGCGCTCAGGTAATATAATGAGACTGGTACCCATAACACGTTTTCGTCAGTAATAAAAGCGCGATCATTCAAGGGGACGATAGCAGACCTTCAATGCGGAATGGTTTTGCGCCTCTAATAACTGAGAGCACTATAATAGAAGTGAGTGTATTGTTATGCCATCCT")
```


```{r}
s2 = DNAString("ACTGGAGCGAACTGGACATCAACCCTACTAAGGGAAGAAAATTGGAATAATCATCAGGTACTGAGAACACACGACCCCACCGTTGAGGTTTCGACAGCTTGAATTCTTACAAGGGCTAGCCGTTGCTGGCTAGCCATTTGTCAGAGTGTCTAAGAGCAGACTAAACTACCCTCGTTCCTATATAAACGAAGCTACTACCAGCAAGGTCCGGAACGCAACTCTCAGGATTGATGGGATGTGCACATTTCGTTTGGAGTTGCCGGATAGACGCTCGCAATCCTCTTCGACCACACGGAATGACGCGCCGGTCGCTCCAAATATAGTAGCCCGGGGCGGAAGAGGCGAAACTATATCAGCTTCCGGAACAGATGTCGTTTCTATGGCGCCTTCAAAGAGTGCGACGCCATGCAATCGTACATGCGCCTAGAACTCCTGGATGAGGATCTTTAAGAACGACTGGGTAAGCTAGATACATTTCAGTCTGGTTATGGTCTAAGTAGAACAGGTAACCCATGTACATTCAAATGTATGAGTGCCGGTCCATGCTTATCGGTTAACATGACCAACATCGAAACTATGGTGCGAGTTTAAGTGCAATACCAAAGGCCAAATGAGCGCACTCCATAGGCTGACCCGCATAATAATGGTCTGGTCAAAGGATTAGAAGTAAGATGCTACGATAAGCTTCCCGCGGTCACGATGACCCTTTAGCCTCACCTTATTAAATGGCTAAATTTTTTATAACTGCTGCGGGCAGGGGAACCCAGCCGAGCTCCGTGGATTTACCGAGGCCGCTTACAGTCACATGTTTATGTCAACAACTTGTGCTCGAGTATGCGAGGGCCCTATTGAATCTCGGAAATGTGGCTTGGTTGTCGACCTCTCTAGTCCCGTAGTTCTCAACTCGGAATGGATGGCTGAAACATACGTCCA")
```




```{r}

hamming_distance = function (s1, s2){    
    dis = 0
    for (i in 1:length(s1)){
        if (s1[i] != s2[i]){
            dis = dis + 1
        }
    }
    return(dis)
}

k = hamming_distance(s1, s2)
k

```

```{r}
ss = DNAStringSet(list(s1, s2))
stringDist(ss, method = "hamming")
```


5. zadatak. Nadi udaljenost izmedu sekvenci ako tranzicije kaznjavamo s 1, a transverzije s 2. 

```{r}

pu = DNAStringSet(c("A","G"))
py = DNAStringSet(c("C","T"))




tt_distance = function (s1, s2){    
    dis = 0
    ts = 0
    tv = 0 
    for (i in 1:length(s1)){
        if (s1[i] != s2[i]){
            if (((s1[i] == (pu[1]))& (s2[i] == (pu[2]))) | ((s1[i] == (pu[2]))& (s2[i] == (pu [1]))))     {
                ts = ts + 1
            }
            if (((s1[i] == (py[1]))& (s2[i] == (py [2]))) | ((s1[i] == (py[2]))& (s2[i] == (py [1]))))     {
                ts = ts + 1
            }
            else{
                tv = tv + 1
            }
            
        }
    }
     
    dis = ts*1 + tv*2
    return(dis)
}

k = tt_distance(s1, s2)
k

```


```{r}
matrica = nucleotideSubstitutionMatrix(match = 2, mismatch = -1, baseOnly = F)
matrica
```



```{r}
stringDist(ss, method = "levenshtein")
```

```{r}
mat = nucleotideSubstitutionMatrix(match = 1, mismatch = -1, baseOnly = TRUE)

pairwiseAlignment(pattern = "ACTCGCAC", subject = "ATAGAC",gapOpening = -1,substitutionMatrix = mat, type="global")
```



Genomic Ranges

```{r}
ir1 = IRanges(start=1:10, width=10:1)
ir1
```

```{r}
ir2 = IRanges(start = c(1, 25), width = 3)
ir2
```


```{r}
ir3 = IRanges(start = c(1, 1, 4, 10), end = c(6, 3, 8, 10))
ir3
```

```{r}
ir4 = reduce(ir3, min.gapwidth = 1)
```

```{r}
disjoin(ir4)
```


```{r}
gaps(ir3)
```



```{r}

gr = GRanges(c("seq1", "seq1", "seq2"), 
              IRanges(c(15, 18, 1233), width=2),
              strand = c("-", "+", "+"))

gr
grlist = GRanges(seqnames="seq1",ranges=IRanges(start=c(15, 16),width=1), strand = c("+"))

grlist

countOverlaps(gr[1], grlist)
countOverlaps(gr[1], grlist, ignore.strand=TRUE)
findOverlaps(gr[1], grlist)
findOverlaps(gr[1], grlist, ignore.strand=TRUE)


```


Zadatak 6. Nadi broj i mjesta ponavljanja obrasca "AGTGCT" u genomu vrste E. coli. 

```{r}
biocLite("BSgenome.Ecoli.NCBI.20080805")
require(BSgenome.Ecoli.NCBI.20080805)

eco = Ecoli$NC_000913

```

```{r}
eco = Ecoli$NC_000913
```

```{r}
genome = DNAStringSet(eco)
```

```{r}
freqPattern = countPattern("AGTGCT", eco)
freqPattern
```

```{r}
pos = matchPattern("AGTGCT", eco)
```


